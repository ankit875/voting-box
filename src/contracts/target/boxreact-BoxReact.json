{
  "transpiled": true,
  "noir_version": "1.0.0-beta.0+b3f4ad661c8c6f88544d714fd5b7b6f58a8ce4ad-aarch64",
  "name": "BoxReact",
  "functions": [
    {
      "name": "getNumber",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "owner",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "owner",
                "type": {
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                }
              },
              {
                "name": "randomness",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "header",
                "type": {
                  "fields": [
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "nonce",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "storage_slot",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "note_hash_counter",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::note::note_header::NoteHeader"
                }
              }
            ],
            "kind": "struct",
            "path": "value_note::value_note::ValueNote"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "7Z3hbty2EoXfxb/zg+RwyGFfpbgo0jQtDARJkaQXuCjy7le7trSbSBVrUfCes+KfwEkk+czx+nzDTWb898Nv73/9649fHj/+/unLw08///3w4dO7t18fP30cfvf3tzcPv35+/PDh8Y9frv/4wZ1+8eV8/Zc/3348/fbL17efvz785FNxbx7ef/xt+DA7Nzzh98cP7x9+SuHbm9nF5uz5WgtputRk4VIN+nyp6uWp3sVv/3nzEFy7FC2jFPPrUqKMl8ZkMym+WUpx6fnaEty6lORGV9KVgaOU0C4lxlGK5ooUGx97/dRRiixKCWmSEnJFincy1uqd6eUzJLd0tY0e+nL5GgVLZzURSo1CqUlQajKUGoNSU5DUiINS46HUBCg1r57FOqoJLnynZgHDIcrUEpQLiMUt6ZDpyfGKlGHpwSE4P6oIvqxfrDKKUInXl57si92+Fvu029diX+r2tdiXu30t9lm3r8W+0u1rsC+6bl+Lfb7b12Jf6Pa12NdPHU32xW5fi3391FG1L+XRvqt3tZ/t66eOJvv6qaPJvn7qqNmXpmvT95ee7Ounjhb7tJ86muzrp44m+/qpo8m+fuposi92+1rs66eOJvv6qaPJvn7qaLKvnzqa7Ounjhb7Uj91NNnXTx1N9vVTx9yTfpSYexK7JzNPetM/96R38nNPens+96T33HNPeiM98yT37njuSW955570PnbuSe9j557E7snMk97Hzj3pfezck97Hzj3pfezck97Hzjyx3sfOPel97NyTg2ZsvHii4QdPyjG/d3KYVOS4/eKTgcf8RnuJgT7lyYxkP/6/1HLM0+WOBh7zKLqjgbEb2GbgMQ+5LzIw26jCm5tR+Jgn4h0NPGZrt6OBxzxr72jgMQ/m+xnoXT+KtDrYzyKtDvbDSKuD/TTS6mDsDjY62M8jrQ72A0mrg/1E0upgP5K0OtjPJI0O+n4maXWwn0laHexnkqqDxY/L5H2RuYP9TNLqYOwONjq4w5nEX13sc8VBmf7ZX9SvP7hYnL4y7nKt1/IkPfFKz7zSjVd6ve+0vP4ZNJdplZVF++5TLOjJ06r2YiLT1dkvBlEpE2+Hj+P15Sf5wXHL99zyA7d84ZYfueUrt/zELT9zyzdu+dzUFW7qCjZ1h9PXJH/4eC4fm7pV+djUrcrHpu7wjxlX8vNcPjZ1q/KxqVuVj03dQfP0vsjpNzP52NStysembk1+xKZuVT44dWvywalbkw9O3Zp8cOrW5INTtyYfnLo1+dzUjejUVXeRf/V29Cgfnbrr8hWduhX54NTNl3+eGD7WmXxw6tbkg1O3Jh+cuhbCJN+CzOSDU7cmH5y6Nfng1LWLkOHjeXCCU7cmH5y6FfkJnLp2eYd5+Hj2Pk8Cp25NPjh1a/KBqHvWA4TRsx4gLp71AIHurAeIXGc9QCg66wFiy0lPBoLFWQ9Q+p/1AMX5WQ9YPmewfM5g+ZzB8jmD5XMGy+cMls8Gls8Gls8Gls8Gls8Gls8Gls8Gls8Gls8Gls8Gls8FLJ8LWD4XsHwuYPlcwPK5gOVzAcvnApbPBSyfC1Y+B4eVz8Fh5XNwWPkcHFY+B4eVz8Fh5XNwWPkcHFY+B4eVz8GB5bMHy2cPls8eLJ89WD57sHz2YPnswfLZv3o+W7JJj4WZHgPTU7D0vP6SgIoeD6YngOkRMD0RTI+C6UlgesDyOYDlcwDLZwHLZwHLZwHLZwHLZwHLZwHLZwHLZwHLZwHLZwHL5wiWzxEsnyNYPkewfI5g+RzB8jmC5XMEy+cIls8RLJ8VLJ8VLJ8VLJ8VLJ8VLJ8VLJ8VLJ8VLJ8VLJ8VLJ8TWD4nsHxOYPmcwPI5geVzAsvnBJbPCSyfE1g+J7B8zmD5nMHyOYPlcwbL5wyWzxksnzNYPmewfM5g+ZzB8tnA8tnA8tnA8tnA8tnA8tnA8tnA8tnA8tnA8tnA8rmA5XMBy+cCls8FLJ8LWD4XsHwuYPlcwPK5gOVzwcpncVj5LA4rn8Vh5bM4rHwWh5XP4rDyWRxWPovDymdxWPksDiyfPVg+e7B89mD57MHy2YPlswfLZw+Wz2DzgwI2Pyhg84MCNj8oYPODAjY/KGDzgwI2Pyhg84MCNj8oYPODAjY/KGDzgwI2Pyhg84MCNj8oYPODAjY/KGDzgwI2Pyhg84MCNj8oYPODAjY/KGDzgwI2Pyhg84MCNj8oYPODAjY/KGDzgwI2Pyhg84MCNj8oYPODAjY/KGDzgwI2Pyhg84MCNj8oYPODAjY/KGDzgwI2Pyhg84MCNj8oYPODAjY/KGDzgwI2Pyhg84MCNj8oYPODAjY/KGDzgwI2Pyhg84MCNj8oYPODAjY/KGDzgwI2Pyhg84MCNj8oYPOD8vrzg0V01FMkzfQImJ4IpkfB9CQwPRlMj4HpKVh6Xn9+sKLHg+kBy+cCls8FLJ8LWD6/+vygd86NP0Dl9HGeKcpwigxOUXl9RXJRpM5dK5pfHvL0ohs+vHrRndTHV5853Fe9p1YfqNULtfpIrV6x1cec5fnqaFcXe1ee9Cdy/Zlcv5HrB2duTb8Hp240X8aH+6Lf6V+QEsN48bWQoE+1gjN611rBib5rreD8f1mton78jh3e5wjz79h4qGrR+4t9q0XvRvatFr132bda9E5n32rR+6Jdqw131UVVq72rPqpa7V11UtVqD9VLvfqc/W2rPVQvFQ7VS4VD9VLhUL1UOFQvJYfqpYS4lzrrJ+6OzvqJ+52z/oitX4OfHh5CmusH70mq+sG7jKp+8L7hO/0ic/3gnUBVPzjba/ojOK11+PST/jJ//Udw/lb1g/O3qh/9+1f8+L8fVOK8f1Pw109ycVSSXIpz/VCvn7MiqI7srCjCKXr9rmlI/4uiWPs/Q2lSEpJdXfykPlGrz9TqjVp9YVafHLV6T60+UKsXavWRWj01axM1axM1axM1axM1azM1azM1azM1azM1a199M8i+6qlZm6lZm6lZm6lZm6lZa9SsNWrWGjVrjZq1r77lZV/11Kw1atYaNWuNmrVGzdpCzdpCzdpCzdpCzdpX39izr3pq1hZq1hZq1hZq1hZm1qpjZq06ZtaqY2atOmbWqmNmrTpm1qpjZq06ZtaqY2atOmrWemrWemrWemrWemrW3mCbz57qqVnrqVnrqVnrqVnrqVkbqFkbqFkbqFkbqFl7g20ve6qnZm2gZm2gZm2gZm2gZq1Qs1aoWSvUrBVq1t5gL8me6qlZK9SsFWrWCjVrhZq1kZq1kZq1kZq1kZq1kZq1kZq1kZq1kZq1kZq1kZq1Ss1apWatUrNWqVl7g11Qe6qnZi313iil3hul1HujlHpvlFLvjVLqvVFKvTdKqfdGKfXeKKXeG6XUe6OUem+UUu+NUuq9UUq9N0qp90Yp9d4opd4bpdR7o5R6b5RS741S6r1RSr03Sqn3Rin13iil3hul1HujlHpvlFLvjVLqvVFKvTdKqfdGKfXeKKXeG6XUe6OUem+UUu+NUuq9UUq9N0qp90Yp9d4opd4bpdR7o5R6b1TC2ht1VgTFz7MiKCaeFUFx7qwIil1nRVA8OiuCYsxZERQ3zoqgWHBSdIutJ2oXRVlnil7/q5bCRVESmykyOEU7U1lDRZEEHX8MpoQcfsDs3mssWuV4LDnhteUMIkY5Eq++wRaujX6SHv31N+OTdOGVHnmlK6/0xCs980o3XumFVro4XumeVzovTYWXpnsvkXhN6bw0FV6aCi9NhZemwkvTyEvTyEvTyEvTW8w9W7m8K+Pkx3dlbjHLXFEU4BQJnKIIp0jhFCU4RRlOkcEpKmiKElxmJ7jMTnCZneAyO8FldoLL7ASX2QkusxNcZie4zM5wmZ3hMjvDZXaGy+wMl9kZLrMzXGZnuMzOcJmd4TLb4DLb4DLb4DLb4DLb4DLb4DLb4DLb4DLb4DLb4DK7wGV2gcvsApfZBS6zC1xmF7jMLnCZXeAyu8BldkHL7OzQMjs7tMzODi2zs0PL7OzQMjs7tMzODi2zs0PL7OzQMjs7uMz2cJnt4TLbw2W2h8tsD5fZHi6zPVxme7jM9nCZ7eEyO8BldoDL7ACX2QEuswNcZge4zA5wmR3gMjvAZXaAy2yBy2yBy2yBy2yBy2yBy2yBy2yBy2yBy2yBy2yBy+wIl9kRLrNv8DNeV7bBvPDycwHKXkDCLiCZD89XJwvlcvGTeqj9Ri9WD7UL6cXqC7r6JJN6+2HiMd9g4nFP9Z5afaBWL9TqwYlbUQ+O24p6eNauqodn7ap6eNauqqdmbaJmbaJmbaJmbaJm7Q0ma/dUT83aRM3aRM3aRM3aRM3aTM3aTM3aTM3aTM3aG0xE76memrWZmrWZmrWZmrWZmrVGzVqjZq1Rs9aoWXuDSfY91VOz1qhZa9SsNWrWGjVrCzVrCzVrCzVrCzVrb7CBYE/11Kwt1Kwt1Kwt1KwtzKw1x8xac8ysNcfMWnPMrDXHzFpzzKw1x8xac8ysNcfMWnPUrPXUrPXUrPXUrPXUrL3Bxo891VOz1lOzFutnmr9YPTVrPTVrAzVrAzVrAzVrAzVrb7CpZU/11KwN1KwN1KwN1KwN1KwVatYKNWuFmrVCzdobbNjZUz01a4WatULNWqFmrVCzNlKzNlKzNlKzNlKzFn17VEU9NWvx90atqqdmLf7eqFX11Kyl3htl1HujjHpvlFHvjTLqvVFGvTfKqPdGGfXeKIPfG1XctKOx+Jl6dNauqoffG7WuHp216+rRWbuuHp216+qhaHVWBEWgsyIoqpwVQZHipOgG23ScpEmROrf+XaCi49Uq6bJf2LvypD+C60/T1ZpSnutXcv2JXH8m12/k+gu3/hvsd9lXP3r+1/QHdP1eVvULuX54/lb0w/O3oh+evyWOD89e5vrh+VvRD8/fin54/q7rL/D8reiH529FPzx/K/rR+ZvVJv15QT86f2v60flb04/O35p+dP5m9Rf9ca4fnb81/ej8XddfHDp/a/rR+VvTj87fmn58/q7rx+fvRb/5uX58/q7rx+fvun50/ppM/YOpzPWj87emH52/Ff0enb81/ej8NR8v+r/P//nV0Y3f7NFfvVcX9KlWdFbvWSs61/esNR6oVvR+YWutwea1ovcWe9YK34fsWCt8z7JjrfD9zYtqtamZcGlWa4DvhXas9b76pvVa76pv0suBMC3Ueld9U6XWeKBa76pvqtR6V31Tpda76psqtd5V31Sp9a76JlWdatVZrXJXfVOl1rvqmyq13lnftFrrgfqmG+yPul2tB+qb5EB9kxyob5ID9U1yZ33TWq3xQH1TPFDfFA/UN8U765tWa40HyqYD9U3xQH1TPFDfFA/UN8UD9U16Z33Taq3ofdNwEhsfXjR8V+tZP3gvlFwclSSX5v8/V8H7m6r+SK4fvA+p6gfvLar6wfuFqn7wHqCqH5zrNf0JnNVV/eD8reon528i528i528i528i528i528i528i528m5y/6fsGqfnL+ZnL+ou93rOon5y/6fseqfnL+ou93rOon5y/6fseqfnL+ou93rOon5y/6fseqfnL+ou93rOon5y/6fseqfnL+ou93rOon5y/6fseqfnL+ou93rOon5y/6fseqfnL+ou93rOrn5u/wNG4AD0/jJvDwNG4En57GXgA3hIencVN4eBo3hoencXN4eBo3iIensZMYfdVjvQB2EqMvcKwXwE5i9FWL9QLYSYy+FLFeADuJ0dcX1gtgJzH6osF6AewkRl8JWC+AncToy/vqBbCTGH3NXr0AdhKjL8SrF8BOYvTVdfUC2EmMvmSuXgA7idHXwdULYCcx+uK2egHsJEZfsVYvgJ3E6MvQ6gWwkxh9bVm9AHYSoy8YqxfATmL0VWD1AthJjL60q14AO4nR12vVC2AnMfnSrOEJ7CQmX5s1PIGdxOSLs4YnsJOYfHXW8AR2EpMvzxoKYCcx+fqsoQB2EpMv0BoKYCcx+QqtoQB2EpMv0RoKYCcx+RqtoQB2EpMv0hoKYCcx+SqtoQB2EpMv0xoKYAcZ+Toq78j3UQ0FsIPsX2zkyW69gNN/eZkU2dUPKkpu6Wod5QcXpmuDpYVrLUR5vthC8dPV4pZ0yPTkGC6Sw9KDg/jxwUGCv774yZXcXVlwxborC66U7srclX+x6eiIrvjuyoIrobuy4Ioc0pVQyuSKD+sXn6ZGpvqyzi2M3cJWC7VbWLPQTz2292pzC4/ZYu9q4TH78V0tPGbzvquFx+z0X2ZhDpOFZYYT747Z6r3IwujG94OGD21uYe8Lmy2M3cJWC3tf2Gxh7wurFqpMZqjmuYW9L2y2sPeFzRb2vrDVQn/Mt4t3tfCY7y3vamE/nTRb2E8nzRbGbmGrhf100mxhP500W9hPJ80W9tNJs4X9dNJqYeink2YL++mkbmEuk4WlzC3sp5NmC/vppNnC2C1stbC31lULxU8Wisz/7ST01rrZwt5aN1vYW+tWC6W31s0W9ta62cLeWjdb2FvrZgtjt7DVwv7Gf7OF/XTSbGE/nTRb2E8ndQs1Tham+Vuu0k8nrRbGfjpptrCfTpot7KeTZgv76aTZwtgtbLWwn05ahyZiP500W9hPJ80W9tNJq4XaW+vvLXxypXfLS670BnjJld7TLriyvJ04x/ETZHWze5bX0ZY4fqKS5p9neQNs5R7ZcE/ccM9yn7m+6sX/wz7P2l1501226a6y5a5/WDJZu8tvuitsuks23RU33bXptWGbXhu26bVhm14btum1UTa9NpYXlq1nzPI6r+L9+H0sC/ekDffkDffYhnvKi+8Jzr04y4LzG+4JG+6RDffEDffohnvShnuWXwdpfI2WXOb32IZ7ysvvWZ72rdzjN9wTNtwjG+6pvQ6W7tnwOvAbXgfLQ0iVe2zDPeXl94QNeRA25EHYkAdhQx6EDXkQNrwOwobXQdjwOggbXgdhw+tANnxNZcPXVDZ8TWXD1zT+Qz02HraKuh92cX8bfvvft58f3/764f2X4abT3/718d3Xx08fn3/79X9/jn/z6+fHDx8e//jlz8+f3r3/7a/P73/58Ond6e8e3PMvP/ug9mY4AJaToPMfnE5vw/HIn+l9vmLoV4ZfbPjcw+f/Pw==",
      "brillig_names": [
        "getNumber"
      ]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "H4sIAAAAAAAA/9VUyw6CMBBseURBOaiJ3kz8gyIYOJJ49x8akKMe8OKNT5eabbqpVRKlJkzSbEs3szNlW0oUKESPvAH9tGnIFdhBDCA6aN/tRgFr9hviQKs7JH/O0iQw+BtQ/5OfWtIvIPktnT+bAM+xVfzYi6w77UaIesKWZ/nPbHpe9fhc/MFnh32k1caghm+uIYci3RuYR4Y8iRlRd9prh/eV5YzJei7w++RVO67va/lrWIeafvmOFV/qrDMe1wmv+YFXVVrypcYv4KBzGnMvbGHe1wvY45yo3mjul/J0vZ0b0gNB8gCVxsvQjgYAAA==",
      "debug_symbols": "nZJLCoMwFEX38sYOzMdP3IoUiRolEBKJsVDEvTeKLbY4SSYPbrjnTnJW6EW7jI3Ug5mhqldQpuNOGu3TuiXQWqmUHJvrM6T7QejozxPXe5wdtw4qghMQuoeKpp4epBJQ5Xh7JIBwYJ8E9mlgPwvr49t9Rlh+Eoxi8mVQyg4oi4HyGKiIgcoIiNx+PKNl9oGylP5Cm49PbiVvlTjFGhbdXTxzr0n8KTdZ04l+sWKX7+KdvzUqEoz9rJ9+Aw==",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "setNumber",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 20
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "1705275289401561847": {
            "error_kind": "string",
            "string": "Mismatch note header storage slot."
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2429784973622283587": {
            "error_kind": "string",
            "string": "Can only emit a note log for an existing note."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3151558035338938026": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 75
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6869395374906889440": {
            "error_kind": "string",
            "string": "Mismatch note header contract address."
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8193989641828211937": {
            "error_kind": "string",
            "string": "ciphertext length mismatch"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "txs_effects_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "number",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "owner",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "txs_effects_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "random",
        "get_note_internal",
        "decompose_hint",
        "get_public_keys_and_partial_address",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "debug_log_oracle_wrapper",
        "get_random_bytes",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "compute_note_hash_and_optionally_a_nullifier",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 20
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "contract_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "storage_slot",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "note_type_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "compute_nullifier",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "serialized_note",
            "type": {
              "kind": "array",
              "length": 3,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "array",
            "length": 4,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "compute_note_hash_and_optionally_a_nullifier"
      ]
    },
    {
      "name": "constructor",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "initializer"
      ],
      "abi": {
        "error_types": {
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2429784973622283587": {
            "error_kind": "string",
            "string": "Can only emit a note log for an existing note."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3151558035338938026": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 75
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8193989641828211937": {
            "error_kind": "string",
            "string": "ciphertext length mismatch"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "txs_effects_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "number",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "owner",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "txs_effects_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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cHviJlW6GkFSpStuUqUn7pZU6YqbVOmKm1TpiptU6YrbwO2Jm1TpiptU6YqbVOmKm1TpiptU6Yk7kCpdcZMqXXGTKl1xkypdcRu4PXGTKl1xkypdcZMqXXGTKs/EvXedSSBVeuLuSJWuuEmVrrhJlaeeKneuoupIla64DdyORrAjVbriJlW64iZVuuImVbriJlV64jZSpStuUqUrblKlK25SpStuA7cnblKlK25SpStuUqUrblKlK25SpSfunlTpiptU6YqbVOmKm1TpitvAfSLuvQsfelKlK25SpStuUqUrblLlqafKnct6elKlJ+6BVOlpBAdSpStuUqUrblKlK24DtyduUqUrblKlK25SpStuUqUrblKlJ+6RVOmKm1TpiptU6YqbVOmK28DtiZtU6YqbVOmKm1TpiptU6YqbVHkm7r2d+IlU6YqbVOmKm1TpiptUeeqpcuc6k8nA7YmbVOlpBCdSpStuUqUrblKlK25SpSfumVTpiptU6YqbVOmKm1TpitvA7YmbVOmKm1TpiptU6YqbVOmKm1Tph7trGlKlK25SpStuUqUrblLlmbi3t4YvuA3cnrhJla64SZWuuEmVp54qNy98uOAmVbriJlV6GsGWVOmKm1TpiptU6YqbVOmK28DtiZtU6YqbVOmKm1TpiptU6YqbVOmJO5AqXXGTKl1xkypdcZMqXXEbuD1xkypdcZMqz8S9t1cZSJWuuEmVrrhJlZ64O1LlqafKnZ34jlTpiptU6WkEO1KlK24DtyduUqUrblKlK25SpStuUqUrblKlJ24jVbriJlW64iZVuuImVbriNnB74iZVuuImVbriJlW64iZVnol7b/PMSJWeuHtSpStuUqUrblLlqafKna3hnlTpitvA7WgEe1KlK25SpStuUqUrblKlK25SpSfugVTpiptU6YqbVOmKm1TpitvA7YmbVOmKm1TpiptU6YqbVOmKm1R5Ju693ZyRVOmKm1TpiptU6YqbVHnqqXJnr3I0cHviJlV6GsGRVOmKm1TpiptU6YqbVOmJeyJVuuImVbriJlW64iZVuuI2cHviJlW64iZVuuImVbriJlW64iZVnol7b3thJlW64iZVuuImVbriJlWeeqrc2TybDdyeuEmVnkZwJlW64iZVuuImVbriJlU64m4bUqUrblKlK25SpStuUqUrbgO3J25SpStuUqUr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5+pCw5+mLoYuSepCO5ymLnSnaepCs5imLvRuaepCK5WkLj2dTZq60GikqQt5P01dyPtp6mLokqQu5P00dSHvp6kLeT9NXcj7aepC3k9Sl4G8n6Yu5P00dSHvp6kLeT9NXQxdktSFvJ+mLuT9NHUh76epC3k/TV3I+0nqMpL309SFvJ+mLuT9NHUh76epi6FLkrqQ99PUhbx/mi5Dc/2qog2hiVET4d1Qk8rdUBO0vVBPZOfzUC/fFLdhfICaOOyGmoTrhprQ6obaQO2Fmmjp5kBIi26oSYtuqEmLbqhJi16nxZm06IaatOiGmrTohpq06IbaQO2FmrTohpq06IaatOiGmrTohpq06BTMQ0NadENNWnRDTVp0Q01adDothsZA7YWatOiGmrTohpq06IaatOiGmrTohbolLbqhJi26oSYtuqEmLXoF89ZA7YWatOiGmrTohpq06HZaJC26oSYteqEOpEU31KRFN9SkRTfUpEU31AZqL9SkRTfUpEU31KRFr2AeSItuqEmLXqg70qIbatKi12mxIy26oSYtuqE2UHuhJi26oSYtuqEmLbqhJi26oSYteqE20qIbatKiVzA30qIbatKiG2oDtRdq0qLbaZG06IaatOiGmrTohpq06IW6Jy26oSYtuqEmLbqhJi26oTZQe6EmLXoF85606IaatOiGmrTohpq06HVaHEiLbqhJi26oSYtuqEmLbqgN1F6oSYtuqEmLbqhJi26oSYtuqEmLXsF8JC26oSYtuqEmLbqhJi16nRZHA7UXatKiG2rSohtq0qIbatKiG2rSohfqibTohpq06IaatOiGmrToFcwnA7UXatKiG2rSohtq0qLbaZG06IaatOiFeiYtuqEmLbqhJi26oSYtuqE2UHuhJi26oSYtuqEmLXoF85m06IaatOiEumtIi26oSYtOp8WuIS26oSYtuqE2UHuhJi26oSYtuqEmLbqhJi26oSYteqFuSYtuqEmLXsG8JS26oSYtuqE2UHuhJi26nRZJi26oSYtuqEmLbqhJi16oA2nRDTVp0Q01adENNWnRDbWB2gs1adErmAfSohtq0qIbatKiG2rSotdpsSMtuqEmLbqhJi26oSYtuqE2UHuhJi26oSYtuqEmLbqhJi26oSYtegVzIy26oSYtuqEmLbqhJi16nRbNQO2FmrTohpq06IaatOiGmrTohpq06IW6Jy26oSYtuqEmLbqhJi16BfPeQO2FmrTohpq06IaatOh2WiQtuqEmLXqhHkiLbqhJi26oSYtuqEmLbqgN1F6oSYtuqEmLbqhJi17BfCAtuqEmLXqhHkmLbqhJi16nxZG06IaatOiG2kDthZq06IaatOiGmrTohpq06IaatOiFeiItuqEmLXoF84m06IaatOiG2kDthZq06HZaJC26oSYtuqEmLbqhJi16oZ5Ji26oSYtuqEmLbqhJi26oDdReqEmLXsF8Ji26oSYtuqEmLbqhJi06nRatIS26oSYtuqEmLbqhJi26oTZQe6EmLbqhJi26oSYtuqEmLbqhJi06BXNrSYtuqEmLbqhJi26oSYtep8XWQO2FmrTohpq06IaatOiGmrTohpq06IU6kBbdUJMW3VCTFt1Qkxa9gnkwUHuhJi26oSYtuqEmLbqdFkmLbqhJi16oO9KiG2rSohtq0qIbatKiG2oDtRdq0qIbatKiG2rSolcw70iLbqhJi16ojbTohpq06HVaNNKiG2rSohtqA7UXatKiG2rSohtq0qIbatKiG2rSohfqnrTohpq06BXMe9KiG2rSohtqA7UXatKi22mRtOiGmrTohpq06IaatOiFeiAtuqEmLbqhJi26oSYtuqE2UHuhJi16BfOBtOiGmrTohpq06IaatOh1WhxJi26oSYtuqEmLbqhJi26oDdReqEmLbqhJi26oSYtuqEmLbqhJi17BfCItuqEmLbqhJi26oSYtep0WJwO1F2rSohtq0qIbatKiG2rSohtq0qIX6pm06IaatOiGmrTohpq06BXMZwO1F2rSohtq0qIbatKi22mRtOiGmrTohLpvSItuqEmLbqhJi26oSYtuqA3UXqhJi26oSYtuqEmLTsG8b0iLbqhJi16oW9KiG2rSotdpsSUtuqEmLbqhNlB7oSYtuqEmLbqhJi26oSYtuqEmLXqhDqRFN9SkRa9gHkiLbqhJi26oDdReqEmLbqdF0qIbatKiG2rSohtq0qIX6o606IaatOiGmrTohpq06IbaQO2FmrToFcw70qIbatKiG2rSohtq0qLXadFIi26oSYtuqEmLbqhJi26oDdReqEmLbqhJi26oSYtuqEmLbqhJi17BvCctuqEmLbqhJi26oSYtep0WewO1F2rSohtq0qIbatKiG2rSohtq0qIX6oG06IaatOiG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",
      "brillig_names": [
        "get_contract_instance_internal",
        "decompose_hint",
        "lte_hint",
        "random",
        "notify_created_note_oracle_wrapper",
        "debug_log_oracle_wrapper",
        "get_random_bytes",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "000000000000000000000000000000000000000000000000000000003de78269"
            },
            {
              "kind": "string",
              "value": "ValueNote"
            },
            {
              "fields": [
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "BoxReact"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "numbers",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "number",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "BoxReact::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "BoxReact::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "number",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "BoxReact::setNumber_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "BoxReact::setNumber_abi"
        }
      ]
    }
  },
  "file_map": {
    "104": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "106": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use dep::protocol_types::abis::validation_requests::{\n    key_validation_request::KEY_VALIDATION_REQUEST_LENGTH, KeyValidationRequest,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"
    },
    "108": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "109": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{note::{note_header::NoteHeader, note_interface::NoteInterface}, utils::array};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::{INDEXED_TAGGING_SECRET_LENGTH, IndexedTaggingSecret},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            serialized_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        serialized_note,\n        note_hash,\n        counter,\n    );\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(\n    _nullifier: Field,\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S],\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S]\nwhere\n    Note: NoteInterface<N>,\n{\n    sync_notes_oracle_wrapper();\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let note_content = array::subarray(fields, read_offset + 2);\n\n            let mut note = Note::deserialize_content(note_content);\n            note.set_header(NoteHeader { contract_address, nonce, storage_slot, note_hash_counter });\n\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n/// Same as `get_app_tagging_secret_as_sender`, except it returns the derived tag, ready to be included in a log.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_app_tagging_secret_as_sender(sender, recipient).compute_tag(recipient)\n}\n\n/// Returns the tagging secret for a given sender and recipient pair, siloed for the current contract address.\n/// Includes the last known index used to send a note tagged with this secret.\n/// For this to work, PXE must know the ivpsk_m of the sender.\n/// For the recipient's side, only the address is needed.\npub unconstrained fn get_app_tagging_secret_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> IndexedTaggingSecret {\n    let result = get_app_tagging_secret_as_sender_oracle(sender, recipient);\n    IndexedTaggingSecret::deserialize(result)\n}\n\n#[oracle(getAppTaggingSecretAsSender)]\nunconstrained fn get_app_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> [Field; INDEXED_TAGGING_SECRET_LENGTH] {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them available\n/// for later querying via the `get_notes` oracle.\npub fn sync_notes() {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        sync_notes_oracle_wrapper();\n    }\n}\n\nunconstrained fn sync_notes_oracle_wrapper() {\n    sync_notes_oracle();\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle() {}\n"
    },
    "111": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "119": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, constants::CONTRACT_INSTANCE_LENGTH, contract_class_id::ContractClassId,\n    contract_instance::ContractInstance,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    let (member, exists) = get_contract_instance_deployer_internal_avm(address);\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    let (member, exists) = get_contract_instance_class_id_internal_avm(address);\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    let (member, exists) = get_contract_instance_initialization_hash_internal_avm(address);\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "125": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must be large enough to hold all of\n/// the elements past `offset`.\n///\n/// Example:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n/// ```\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "128": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use crate::utils::point::point_to_bytes;\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n}\n"
    },
    "147": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/initializer.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "148": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::Hash,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(\n    contract_address: AztecAddress,\n    log: [u8; N],\n) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd,\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = AztecAddress::from_field(\n        0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303,\n    );\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"
    },
    "149": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/generators.nr",
      "source": "use dep::protocol_types::point::Point;\n\n// A set of generators generated with `derive_generators(...)` function from noir::std\npub global Ga1: Point = Point {\n    x: 0x30426e64aee30e998c13c8ceecda3a77807dbead52bc2f3bf0eae851b4b710c1,\n    y: 0x113156a068f603023240c96b4da5474667db3b8711c521c748212a15bc034ea6,\n    is_infinite: false,\n};\npub global Ga2: Point = Point {\n    x: 0x2825c79cc6a5cbbeef7d6a8f1b6a12b312aa338440aefeb4396148c89147c049,\n    y: 0x129bfd1da54b7062d6b544e7e36b90736350f6fba01228c41c72099509f5701e,\n    is_infinite: false,\n};\npub global Ga3: Point = Point {\n    x: 0x0edb1e293c3ce91bfc04e3ceaa50d2c541fa9d091c72eb403efb1cfa2cb3357f,\n    y: 0x1341d675fa030ece3113ad53ca34fd13b19b6e9762046734f414824c4d6ade35,\n    is_infinite: false,\n};\npub global Ga4: Point = Point {\n    x: 0x0e0dad2250583f2a9f0acb04ededf1701b85b0393cae753fe7e14b88af81cb52,\n    y: 0x0973b02c5caac339ee4ad5dab51329920f7bf1b6a07e1dabe5df67040b300962,\n    is_infinite: false,\n};\npub global Ga5: Point = Point {\n    x: 0x2f3342e900e8c488a28931aae68970738fdc68afde2910de7b320c00c902087d,\n    y: 0x1bf958dc63cb09d59230603a0269ae86d6f92494da244910351f1132df20fc08,\n    is_infinite: false,\n};\n// If you change this update `G_SLOT` in `yarn-project/simulator/src/client/test_utils.ts` as well\npub global G_slot: Point = Point {\n    x: 0x041223147b680850dc82e8a55a952d4df20256fe0593d949a9541ca00f0abf15,\n    y: 0x0a8c72e60d0e60f5d804549d48f3044d06140b98ed717a9b532af630c1530791,\n    is_infinite: false,\n};\n\nmod test {\n    use crate::generators::{G_slot, Ga1, Ga2, Ga3, Ga4, Ga5};\n    use dep::protocol_types::point::Point;\n    use std::hash::derive_generators;\n\n    #[test]\n    unconstrained fn test_generators() {\n        let generators: [Point; 6] = derive_generators(\"aztec_nr_generators\".as_bytes(), 0);\n        assert_eq(generators[0], Ga1);\n        assert_eq(generators[1], Ga2);\n        assert_eq(generators[2], Ga3);\n        assert_eq(generators[4], Ga4);\n        assert_eq(generators[5], Ga5);\n        assert_eq(generators[3], G_slot);\n    }\n}\n"
    },
    "152": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "153": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/keys/secret_derivation.nr",
      "source": "use crate::utils::point::point_to_bytes;\nuse dep::protocol_types::{constants::GENERATOR_INDEX__SYMMETRIC_KEY, point::Point, scalar::Scalar};\nuse std::{embedded_curve_ops::multi_scalar_mul, hash::sha256};\n\npub fn derive_aes_secret(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret = point_to_bytes(multi_scalar_mul([point], [secret]));\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret[i];\n    }\n\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nunconstrained fn test_derive_aes_secret_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let key = derive_aes_secret(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158,\n        236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159,\n    ];\n    assert_eq(key, key_from_typescript);\n}\n"
    },
    "159": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/state_vars/private_mutable.nr",
      "source": "use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Serialize},\n};\n\nuse crate::context::{PrivateContext, UnconstrainedContext};\nuse crate::note::{\n    lifecycle::{create_note, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_note, view_notes},\n    note_interface::{NoteInterface, NullifiableNote},\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateMutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nmod test;\n\nimpl<T, Context, let N: u32> Storage<T, N> for PrivateMutable<T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{}\n\nimpl<Note, Context> PrivateMutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateMutable>` type (for example), because the storage slot often also identifies an actor. e.g.\n    // the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    // Note: subsequent nullification of this state variable, via the `replace` method will not be leaky, if the `compute_nullifier()` method of the underlying note is designed to ensure privacy.\n    // For example, if the `compute_nullifier()` method injects the secret key of a note owner into the computed nullifier's preimage.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note, let N: u32> PrivateMutable<Note, &mut PrivateContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    // docs:start:initialize\n    pub fn initialize(self, note: &mut Note) -> NoteEmission<Note> {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:replace\n    pub fn replace(self, new_note: &mut Note) -> NoteEmission<Note> {\n        let (prev_note, note_hash_for_read_request): (Note, Field) =\n            get_note(self.context, self.storage_slot);\n\n        // Nullify previous note.\n        destroy_note_unsafe(self.context, prev_note, note_hash_for_read_request);\n\n        // Add replacement note.\n        create_note(self.context, self.storage_slot, new_note)\n    }\n    // docs:end:replace\n\n    pub fn initialize_or_replace(self, note: &mut Note) -> NoteEmission<Note> {\n        // `check_nullifier_exists` is an unconstrained function - we can constrain a true value by providing an\n        // inclusion proof of the nullifier, but cannot constrain a false value since a non-inclusion proof would only\n        // be valid if done in public.\n        // Ultimately, this is not an issue ginen that we'll either:\n        //  - initialize the state variable, which would fail if it was already initialized due to the duplicate\n        //    nullifier, or\n        //  - replace the current value, which would fail if it was not initialized since we wouldn't be able to produce\n        //    an inclusion proof for the current note\n        // This means that an honest oracle will assist the prover to produce a valid proof, while a malicious oracle\n        // (i.e. one that returns an incorrect value for is_initialized) will simply fail to produce a proof.\n        let is_initialized =\n            unsafe { check_nullifier_exists(self.compute_initialization_nullifier()) };\n\n        if (!is_initialized) {\n            self.initialize(note)\n        } else {\n            self.replace(note)\n        }\n    }\n\n    // docs:start:get_note\n    pub fn get_note(self) -> NoteEmission<Note> {\n        let mut (note, note_hash_for_read_request) = get_note(self.context, self.storage_slot);\n\n        // Nullify current note to make sure it's reading the latest note.\n        destroy_note_unsafe(self.context, note, note_hash_for_read_request);\n\n        // Add the same note again.\n        // Because a nonce is added to every note in the kernel, its nullifier will be different.\n        create_note(self.context, self.storage_slot, &mut note)\n    }\n    // docs:end:get_note\n}\n\nimpl<Note, let N: u32> PrivateMutable<Note, UnconstrainedContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n\n    // docs:start:view_note\n    pub unconstrained fn view_note(self) -> Note {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"
    },
    "160": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{\n    storage::map::derive_storage_slot_in_map,\n    traits::{Deserialize, Serialize, ToField},\n};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<T, N> for Map<K, T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "17": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"
    },
    "18": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(unsafe { field_less_than(b, a) });\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "19": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "204": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr",
      "source": "use crate::{point::Point, traits::{Deserialize, Empty, Serialize}};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pub pk_m: Point,\n    pub sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"
    },
    "21": {
      "path": "std/hash/mod.nr",
      "source": "pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "240": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash([self.secret, recipient.to_field(), self.index as Field])\n    }\n}\n"
    },
    "26": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "267": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = unsafe { find_index_hint(values, |v: Field| min.lt(v)) };\n    assert_eq(index, 2);\n}\n\n#[test]\nfn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = unsafe { find_index_hint(values, |v: Field| min.lt(v)) };\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concated = array_concat(array0, array1);\n    assert_eq(concated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "27": {
      "path": "std/hash/sha256.nr",
      "source": "use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::{\n        attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n        set_item_byte_then_zeros, set_item_zeros,\n    };\n    use super::INT_BLOCK;\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n\n    #[test]\n    fn test_get_item_byte() {\n        let fld = make_item(10, 20, 30, 40);\n        assert_eq(fld, 0x0a141e28);\n        assert_eq(get_item_byte(fld, 0), 10);\n        assert_eq(get_item_byte(fld, 4), 10);\n        assert_eq(get_item_byte(fld, 6), 30);\n    }\n\n    #[test]\n    fn test_byte_into_item() {\n        let fld = make_item(0, 20, 0, 0);\n        assert_eq(byte_into_item(20, 1), fld);\n        assert_eq(byte_into_item(20, 5), fld);\n    }\n\n    #[test]\n    fn test_set_item_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 0, 0, 0);\n        assert_eq(set_item_zeros(fld0, 3), fld1);\n        assert_eq(set_item_zeros(fld0, 4), 0);\n        assert_eq(set_item_zeros(0, 4), 0);\n    }\n\n    #[test]\n    fn test_set_item_byte_then_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 50, 0, 0);\n        assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_0() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48,\n        ];\n        assert_eq(input.len(), 22);\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 0) };\n        assert_eq(msg_byte_ptr, input.len());\n        assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n        assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n        assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n        assert_eq(msg_block[6], 0);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_1() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        assert_eq(input.len(), 68);\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 64) };\n        assert_eq(msg_byte_ptr, 4);\n        assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n        assert_eq(msg_block[1], 0);\n    }\n\n    #[test]\n    fn test_attach_len_to_msg_block() {\n        let input: INT_BLOCK = [\n            2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n            1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n            1849316213, 1651139939,\n        ];\n        let msg_block = unsafe { attach_len_to_msg_block(input, 1, 448) };\n        assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n        assert_eq(msg_block[1], 0);\n        assert_eq(msg_block[15], 3584);\n    }\n}\n"
    },
    "286": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "292": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress},\n    constants::CONTRACT_INSTANCE_LENGTH,\n    contract_class_id::ContractClassId,\n    public_keys::PublicKeys,\n    traits::{Deserialize, Hash, Serialize},\n};\n\npub struct ContractInstance {\n    pub salt: Field,\n    pub deployer: AztecAddress,\n    pub contract_class_id: ContractClassId,\n    pub initialization_hash: Field,\n    pub public_keys: PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11],\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize([\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15],\n            ]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    pub fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer,\n            ),\n        )\n    }\n}\n"
    },
    "293": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        MAX_FIELD_VALUE,\n    },\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse ec::{pow, sqrt};\nuse std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secrect can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        function_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            function_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "295": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr",
      "source": "use crate::{\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    pub inner: Field,\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\n            [salt, initialization_hash, deployer.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "296": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, salted_initialization_hash::SaltedInitializationHash},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    pub inner: Field,\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress,\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n    ) -> Self {\n        PartialAddress::from_field(poseidon2_hash_with_separator(\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        unsafe {\n            // Safety: `sorted` array is checked to be:\n            //   a. a permutation of `input`'s elements\n            //   b. satisfying the predicate `ordering`\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n}\n"
    },
    "300": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "301": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "302": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash},\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::scoped::Scoped,\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::utils::{arrays::array_concat, field::field_from_bytes};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [tx_hash, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    tx_hash: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage())\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\npub fn compute_tx_logs_hash<let N: u32>(logs: [LogHash; N]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; N * 32];\n    for offset in 0..N {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "303": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n"
    },
    "312": {
      "path": "/Users/ankit.agrawal/nargo/github.com/noir-lang/ec/v0.1.2/src/lib.nr",
      "source": "// Elliptic curve implementation\n// Overview\n// ========\n// The following three elliptic curve representations are admissible:\npub mod tecurve; // Twisted Edwards curves\npub mod swcurve; // Elliptic curves in Short Weierstrass form\npub mod montcurve; // Montgomery curves\npub mod consts; // Commonly used curve presets\n//\n// Note that Twisted Edwards and Montgomery curves are (birationally) equivalent, so that\n// they may be freely converted between one another, whereas Short Weierstrass curves are\n// more general. Diagramatically:\n//\n// tecurve == montcurve `subset` swcurve\n//\n// Each module is further divided into two submodules, 'affine' and 'curvegroup', depending\n// on the preferred coordinate representation. Affine coordinates are none other than the usual\n// two-dimensional Cartesian coordinates used in the definitions of these curves, whereas\n// 'CurveGroup' coordinates (terminology borrowed from Arkworks, whose conventions we try\n// to follow) are special coordinate systems with respect to which the group operations may be\n// implemented more efficiently, usually by means of an appropriate choice of projective coordinates.\n//\n// In each of these submodules, there is a Point struct and a Curve struct, the former\n// representing a point in the coordinate system and the latter a curve configuration.\n//\n// Points\n// ======\n// Points may be instantiated using the associated function `new`, which takes coordinates\n// as its arguments. For instance,\n//\n// `let p = swcurve::Point::new(1,1);`\n//\n// The additive identity may be constructed by a call to the associated function `zero` of no\n// arguments:\n//\n// `let zero = swcurve::Point::zero();`\n//\n// Points may be tested for equality by calling the method `eq`:\n//\n// `let pred = p.eq(zero);`\n//\n// There is also the method `is_zero` to explicitly check whether a point is the additive identity:\n//\n// `constrain pred == p.is_zero();`\n//\n// Points may be negated by calling the `negate` method and converted to CurveGroup (or affine)\n// coordinates by calling the `into_group` (resp. `into_affine`) method on them. Finally,\n// Points may be freely mapped between their respective Twisted Edwards and Montgomery\n// representations by calling the `into_montcurve` or `into_tecurve` methods. For mappings\n// between Twisted Edwards/Montgomery curves and Short Weierstrass curves, see the Curve section\n// below, as the underlying mappings are those of curves rather than ambient spaces.\n// As a rule, Points in affine (or CurveGroup) coordinates are mapped to Points in affine\n// (resp. CurveGroup) coordinates.\n//\n// Curves\n// ======\n// A curve configuration (Curve) is completely determined by the Field coefficients of its defining\n// equation (a and b in the case of swcurve, a and d in the case of tecurve, and j and k in\n// the case of montcurve) together with a generator (`gen`) in the corresponding coordinate system.\n// For example, the Baby Jubjub curve configuration as defined in ERC-2494 may be instantiated as a Twisted\n// Edwards curve in affine coordinates as follows:\n//\n// `let bjj_affine = tecurve::Curve::new(168700, 168696, tecurve::Point::new(995203441582195749578291179787384436505546430278305826713579947235728471134,5472060717959818805561601436314318772137091100104008585924551046643952123905));`\n//\n// The `contains` method may be used to check whether a Point lies on a given curve:\n//\n// `constrain bjj_affine.contains(tecurve::Point::zero());`\n//\n// The elliptic curve group's addition operation is exposed as the `add` method, e.g.\n//\n// `let p = bjj_affine.add(bjj_affine.gen, bjj_affine.gen);`\n//\n// subtraction as the `subtract` method, e.g.\n//\n// `constrain tecurve::Point::zero().eq(bjj_affine.subtract(bjj_affine.gen, bjj_affine.gen));`\n//\n// scalar multiplication as the `mul` method, where the scalar is assumed to be a Field* element, e.g.\n//\n// `constrain tecurve::Point::zero().eq(bjj_affine.mul(2, tecurve::Point::zero());`\n//\n// There is a scalar multiplication method (`bit_mul`) provided where the scalar input is expected to be\n// an array of bits (little-endian convention), as well as a multi-scalar multiplication method** (`msm`)\n// which takes an array of Field elements and an array of elliptic curve points as arguments, both assumed\n// to be of the same length.\n//\n// Curve configurations may be converted between different coordinate representations by calling the `into_group`\n// and `into_affine` methods on them, e.g.\n//\n// `let bjj_curvegroup = bjj_affine.into_group();`\n//\n// Curve configurations may also be converted between different curve representations by calling the `into_swcurve`,\n// `into_montcurve` and `into_tecurve` methods subject to the relation between the curve representations mentioned\n// above. Note that it is possible to map Points from a Twisted Edwards/Montgomery curve to the corresponding\n// Short Weierstrass representation and back, and the methods to do so are exposed as `map_into_swcurve` and\n// `map_from_swcurve`, which each take one argument, the point to be mapped.\n//\n// Curve maps\n// ==========\n// There are a few different ways of mapping Field elements to elliptic curves. Here we provide the simplified\n// Shallue-van de Woestijne-Ulas and Elligator 2 methods, the former being applicable to all curve types\n// provided above subject to the constraint that the coefficients of the corresponding Short Weierstrass curve satisfies\n// a*b != 0 and the latter being applicable to Montgomery and Twisted Edwards curves subject to the constraint that\n// the coefficients of the corresponding Montgomery curve satisfy j*k != 0 and (j^2 - 4)/k^2 is non-square.\n//\n// The simplified Shallue-van de Woestijne-Ulas method is exposed as the method `swu_map` on the Curve configuration and\n// depends on two parameters, a Field element z != -1 for which g(x) - z is irreducible over Field and g(b/(z*a)) is\n// square, where g(x) = x^3 + a*x + b is the right-hand side of the defining equation of the corresponding Short\n// Weierstrass curve, and a Field element u to be mapped onto the curve. For example, in the case of bjj_affine above,\n// it may be determined using the scripts provided at <https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve> that z = 5.\n//\n// The Elligator 2 method is exposed as the method `elligator2_map` on the Curve configurations of Montgomery and\n// Twisted Edwards curves. Like the simplified SWU method above, it depends on a certain non-square element of Field,\n// but this element need not satisfy any further conditions, so it is included as the (Field-dependent) constant\n//`ZETA` below. Thus, the `elligator2_map` method depends only on one parameter, the Field element to be mapped onto\n// the curve.\n//\n// For details on all of the above in the context of hashing to elliptic curves, see <https://datatracker.ietf.org/doc/id/draft-irtf-cfrg-hash-to-curve-06.html>.\n//\n//\n// *TODO: Replace Field with Bigint.\n// **TODO: Support arrays of structs to make this work.\n// Field-dependent constant ZETA = a non-square element of Field\n// Required for Elligator 2 map\n// TODO: Replace with built-in constant.\nglobal ZETA: Field = 5;\n// Field-dependent constants for Tonelli-Shanks algorithm (see sqrt function below)\n// TODO: Possibly make this built-in.\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n// Higher-order version of scalar multiplication\n// TODO: Make this work so that the submodules' bit_mul may be defined in terms of it.\n//fn bit_mul<T,N>(add: fn(T,T) -> T, e: T, bits: [u1; N], p: T) -> T {\n//    let mut out = e;\n//    let n = bits.len();\n//\n//    for i in 0..n {\n//        out = add(\n//            add(out, out),\n//            if(bits[n - i - 1] == 0) {e} else {p});\n//    }\n//\n//    out\n//}\n// TODO: Make this built-in.\npub fn safe_inverse(x: Field) -> Field {\n    if x == 0 {\n        0\n    } else {\n        1 / x\n    }\n}\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\npub fn is_square(x: Field) -> bool {\n    let v = pow(x, 0 - 1 / 2);\n\n    v * (v - 1) == 0\n}\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\nmod tests {\n    use crate::montcurve::affine::Point as MGaffine;\n    use crate::montcurve::curvegroup::Point as MG;\n    use crate::swcurve::affine::Point as SWGaffine;\n    use crate::swcurve::curvegroup::Point as SWG;\n    use crate::tecurve::affine::Curve as AffineCurve;\n    use crate::tecurve::affine::Point as Gaffine;\n    use crate::tecurve::curvegroup::Point as G;\n\n    #[test]\n    fn smoke_test() {\n        // Tests may be checked against https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/tree/main/poc\n        // Define Baby Jubjub (ERC-2494) parameters in affine representation\n        let bjj_affine = AffineCurve::new(\n            168700,\n            168696,\n            Gaffine::new(\n                995203441582195749578291179787384436505546430278305826713579947235728471134,\n                5472060717959818805561601436314318772137091100104008585924551046643952123905,\n            ),\n        );\n        // Test addition\n        let p1_affine = Gaffine::new(\n            17777552123799933955779906779655732241715742912184938656739573121738514868268,\n            2626589144620713026669568689430873010625803728049924121243784502389097019475,\n        );\n        let p2_affine = Gaffine::new(\n            16540640123574156134436876038791482806971768689494387082833631921987005038935,\n            20819045374670962167435360035096875258406992893633759881276124905556507972311,\n        );\n\n        let p3_affine = bjj_affine.add(p1_affine, p2_affine);\n        assert(p3_affine.eq(Gaffine::new(\n            7916061937171219682591368294088513039687205273691143098332585753343424131937,\n            14035240266687799601661095864649209771790948434046947201833777492504781204499,\n        )));\n        // Test scalar multiplication\n        let p4_affine = bjj_affine.mul(2, p1_affine);\n        assert(p4_affine.eq(Gaffine::new(\n            6890855772600357754907169075114257697580319025794532037257385534741338397365,\n            4338620300185947561074059802482547481416142213883829469920100239455078257889,\n        )));\n        assert(p4_affine.eq(bjj_affine.bit_mul([0, 1], p1_affine)));\n        // Test subtraction\n        let p5_affine = bjj_affine.subtract(p3_affine, p3_affine);\n        assert(p5_affine.eq(Gaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_affine.contains(bjj_affine.gen)\n                & bjj_affine.contains(p1_affine)\n                & bjj_affine.contains(p2_affine)\n                & bjj_affine.contains(p3_affine)\n                & bjj_affine.contains(p4_affine)\n                & bjj_affine.contains(p5_affine),\n        );\n        // Test CurveGroup equivalents\n        let bjj = bjj_affine.into_group(); // Baby Jubjub\n        let p1 = p1_affine.into_group();\n        let p2 = p2_affine.into_group();\n        let p3 = p3_affine.into_group();\n        let p4 = p4_affine.into_group();\n        let p5 = p5_affine.into_group();\n        // Test addition\n        assert(p3.eq(bjj.add(p1, p2)));\n        // Test scalar multiplication\n        assert(p4.eq(bjj.mul(2, p1)));\n        assert(p4.eq(bjj.bit_mul([0, 1], p1)));\n        // Test subtraction\n        assert(G::zero().eq(bjj.subtract(p3, p3)));\n        assert(p5.eq(G::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj.contains(bjj.gen)\n                & bjj.contains(p1)\n                & bjj.contains(p2)\n                & bjj.contains(p3)\n                & bjj.contains(p4)\n                & bjj.contains(p5),\n        );\n        // Test SWCurve equivalents of the above\n        // First the affine representation\n        let bjj_swcurve_affine = bjj_affine.into_swcurve();\n\n        let p1_swcurve_affine = bjj_affine.map_into_swcurve(p1_affine);\n        let p2_swcurve_affine = bjj_affine.map_into_swcurve(p2_affine);\n        let p3_swcurve_affine = bjj_affine.map_into_swcurve(p3_affine);\n        let p4_swcurve_affine = bjj_affine.map_into_swcurve(p4_affine);\n        let p5_swcurve_affine = bjj_affine.map_into_swcurve(p5_affine);\n        // Addition\n        assert(p3_swcurve_affine.eq(bjj_swcurve_affine.add(p1_swcurve_affine, p2_swcurve_affine)));\n        // Doubling\n        assert(p4_swcurve_affine.eq(bjj_swcurve_affine.mul(2, p1_swcurve_affine)));\n        assert(p4_swcurve_affine.eq(bjj_swcurve_affine.bit_mul([0, 1], p1_swcurve_affine)));\n        // Subtraction\n        assert(SWGaffine::zero().eq(bjj_swcurve_affine.subtract(\n            p3_swcurve_affine,\n            p3_swcurve_affine,\n        )));\n        assert(p5_swcurve_affine.eq(SWGaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_swcurve_affine.contains(bjj_swcurve_affine.gen)\n                & bjj_swcurve_affine.contains(p1_swcurve_affine)\n                & bjj_swcurve_affine.contains(p2_swcurve_affine)\n                & bjj_swcurve_affine.contains(p3_swcurve_affine)\n                & bjj_swcurve_affine.contains(p4_swcurve_affine)\n                & bjj_swcurve_affine.contains(p5_swcurve_affine),\n        );\n        // Then the CurveGroup representation\n        let bjj_swcurve = bjj.into_swcurve();\n\n        let p1_swcurve = bjj.map_into_swcurve(p1);\n        let p2_swcurve = bjj.map_into_swcurve(p2);\n        let p3_swcurve = bjj.map_into_swcurve(p3);\n        let p4_swcurve = bjj.map_into_swcurve(p4);\n        let p5_swcurve = bjj.map_into_swcurve(p5);\n        // Addition\n        assert(p3_swcurve.eq(bjj_swcurve.add(p1_swcurve, p2_swcurve)));\n        // Doubling\n        assert(p4_swcurve.eq(bjj_swcurve.mul(2, p1_swcurve)));\n        assert(p4_swcurve.eq(bjj_swcurve.bit_mul([0, 1], p1_swcurve)));\n        // Subtraction\n        assert(SWG::zero().eq(bjj_swcurve.subtract(p3_swcurve, p3_swcurve)));\n        assert(p5_swcurve.eq(SWG::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_swcurve.contains(bjj_swcurve.gen)\n                & bjj_swcurve.contains(p1_swcurve)\n                & bjj_swcurve.contains(p2_swcurve)\n                & bjj_swcurve.contains(p3_swcurve)\n                & bjj_swcurve.contains(p4_swcurve)\n                & bjj_swcurve.contains(p5_swcurve),\n        );\n        // Test MontCurve conversions\n        // First the affine representation\n        let bjj_montcurve_affine = bjj_affine.into_montcurve();\n\n        let p1_montcurve_affine = p1_affine.into_montcurve();\n        let p2_montcurve_affine = p2_affine.into_montcurve();\n        let p3_montcurve_affine = p3_affine.into_montcurve();\n        let p4_montcurve_affine = p4_affine.into_montcurve();\n        let p5_montcurve_affine = p5_affine.into_montcurve();\n        // Addition\n        assert(p3_montcurve_affine.eq(bjj_montcurve_affine.add(\n            p1_montcurve_affine,\n            p2_montcurve_affine,\n        )));\n        // Doubling\n        assert(p4_montcurve_affine.eq(bjj_montcurve_affine.mul(2, p1_montcurve_affine)));\n        assert(p4_montcurve_affine.eq(bjj_montcurve_affine.bit_mul([0, 1], p1_montcurve_affine)));\n        // Subtraction\n        assert(MGaffine::zero().eq(bjj_montcurve_affine.subtract(\n            p3_montcurve_affine,\n            p3_montcurve_affine,\n        )));\n        assert(p5_montcurve_affine.eq(MGaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_montcurve_affine.contains(bjj_montcurve_affine.gen)\n                & bjj_montcurve_affine.contains(p1_montcurve_affine)\n                & bjj_montcurve_affine.contains(p2_montcurve_affine)\n                & bjj_montcurve_affine.contains(p3_montcurve_affine)\n                & bjj_montcurve_affine.contains(p4_montcurve_affine)\n                & bjj_montcurve_affine.contains(p5_montcurve_affine),\n        );\n        // Then the CurveGroup representation\n        let bjj_montcurve = bjj.into_montcurve();\n\n        let p1_montcurve = p1_montcurve_affine.into_group();\n        let p2_montcurve = p2_montcurve_affine.into_group();\n        let p3_montcurve = p3_montcurve_affine.into_group();\n        let p4_montcurve = p4_montcurve_affine.into_group();\n        let p5_montcurve = p5_montcurve_affine.into_group();\n        // Addition\n        assert(p3_montcurve.eq(bjj_montcurve.add(p1_montcurve, p2_montcurve)));\n        // Doubling\n        assert(p4_montcurve.eq(bjj_montcurve.mul(2, p1_montcurve)));\n        assert(p4_montcurve.eq(bjj_montcurve.bit_mul([0, 1], p1_montcurve)));\n        // Subtraction\n        assert(MG::zero().eq(bjj_montcurve.subtract(p3_montcurve, p3_montcurve)));\n        assert(p5_montcurve.eq(MG::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_montcurve.contains(bjj_montcurve.gen)\n                & bjj_montcurve.contains(p1_montcurve)\n                & bjj_montcurve.contains(p2_montcurve)\n                & bjj_montcurve.contains(p3_montcurve)\n                & bjj_montcurve.contains(p4_montcurve)\n                & bjj_montcurve.contains(p5_montcurve),\n        );\n        // Elligator 2 map-to-curve\n        let ell2_pt_map = bjj_affine.elligator2_map(27);\n\n        assert(ell2_pt_map.eq(MGaffine::new(\n            7972459279704486422145701269802978968072470631857513331988813812334797879121,\n            8142420778878030219043334189293412482212146646099536952861607542822144507872,\n        )\n            .into_tecurve()));\n        // SWU map-to-curve\n        let swu_pt_map = bjj_affine.swu_map(5, 27);\n\n        assert(swu_pt_map.eq(bjj_affine.map_from_swcurve(SWGaffine::new(\n            2162719247815120009132293839392097468339661471129795280520343931405114293888,\n            5341392251743377373758788728206293080122949448990104760111875914082289313973,\n        ))));\n    }\n\n}\n"
    },
    "322": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/value-note/src/value_note.nr",
      "source": "use dep::aztec::{\n    context::PrivateContext,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::note,\n    note::{\n        note_header::NoteHeader, note_interface::NullifiableNote,\n        utils::compute_note_hash_for_nullify,\n    },\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::poseidon2_hash_with_separator, traits::Serialize,\n    },\n};\n\nglobal VALUE_NOTE_LEN: u32 = 3; // 3 plus a header.\n\n// docs:start:value-note-def\n// ValueNote is used as fn parameter in the Claim contract, so it has to implement the Serialize trait.\n// It is important that the order of these annotations is preserved so that derive(Serialize) runs AFTER the note macro, which injects the note header.\n#[note]\n#[derive(Serialize)]\npub struct ValueNote {\n    value: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NullifiableNote for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m_hash: Field = get_public_keys(self.owner).npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let owner_npk_m_hash: Field = get_public_keys(self.owner).npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, owner: AztecAddress) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        let header = NoteHeader::empty();\n        ValueNote { value, owner, randomness, header }\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.owner == other.owner)\n            & (self.randomness == other.randomness)\n    }\n}\n"
    },
    "51": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "52": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "6": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "62": {
      "path": "/Users/ankit.agrawal/projects/block-c/noir-2jan/private-voting/src/contracts/src/main.nr",
      "source": "use dep::aztec::macros::aztec;\n\n#[aztec]\ncontract BoxReact {\n    use dep::aztec::{\n        prelude::{AztecAddress, PrivateMutable, Map},\n        encrypted_logs::encrypted_note_emission::encode_and_encrypt_note,\n        macros::{storage::storage, functions::{private, initializer}}\n    };\n    use dep::value_note::value_note::ValueNote;\n\n    #[storage]\n    struct Storage<Context> {\n        numbers: Map<AztecAddress, PrivateMutable<ValueNote, Context>, Context>,\n    }\n\n    #[private]\n    #[initializer]\n    fn constructor(\n        number: Field,\n        owner: AztecAddress\n    ) {\n        let numbers = storage.numbers;\n        let mut new_number = ValueNote::new(number, owner);\n\n        numbers.at(owner).initialize(&mut new_number).emit(encode_and_encrypt_note(&mut context, owner, context.msg_sender()));\n    }\n\n    #[private]\n    fn setNumber(\n        number: Field,\n        owner: AztecAddress\n    ) {\n        let numbers = storage.numbers;\n        let mut new_number = ValueNote::new(number, owner);\n\n        numbers.at(owner).replace(&mut new_number).emit(encode_and_encrypt_note(&mut context, owner, context.msg_sender()));\n    }\n\n    unconstrained fn getNumber(owner: AztecAddress) -> pub ValueNote {\n        let numbers = storage.numbers;\n        numbers.at(owner).view_note()\n    }\n}\n"
    },
    "68": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_header::NoteHeader,\n    note_interface::{NoteInterface, NullifiableNote},\n    utils::{compute_note_hash_for_nullify_internal, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    let serialized_note = Note::serialize_content(*note);\n    notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, let N: u32>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, let N: u32>(context: &mut PrivateContext, note: Note)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    notify_nullified_note(nullifier, notification_note_hash, nullifier_counter);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n"
    },
    "69": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote}},\n    utils::array,\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n    compute_unique_note_hash,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash();\n    let header = note.get_header();\n    let nonce = header.nonce;\n    let counter = header.note_hash_counter;\n\n    // If same tx note, read request always uses the normal note hash\n    if counter != 0 {\n        note_hash\n    } else {\n        // If the note comes from a different tx, we need to compute the note hash that reached the tree\n        compute_unique_note_hash(\n            nonce,\n            compute_siloed_note_hash(header.contract_address, note_hash),\n        )\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if (header.note_hash_counter != 0) & (header.nonce != 0) {\n        // Non-revertible note, nullified by a revertible nullifier, we need to nullify the note hash that will reach the tree\n        let siloed_note_hash =\n            compute_siloed_note_hash(header.contract_address, note_hash_for_read_request);\n\n        compute_unique_note_hash(header.nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = deserialize_content(array::subarray(serialized_note, 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, note_hash);\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"
    },
    "7": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n        for i in 0..MaxLen {\n            if i >= len {\n                array[i] = zeroed;\n            }\n        }\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "71": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder},\n    note_interface::{NoteInterface, NullifiableNote},\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::comparison::compare;\nuse dep::protocol_types::constants::{\n    GET_NOTES_ORACLE_RETURN_LENGTH, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    serialized_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note.\n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = serialized_note[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32>(context: PrivateContext, storage_slot: Field, note: Note)\nwhere\n    Note: NoteInterface<N>,\n{\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<let N: u32>(\n    serialized_note: [Field; N],\n    selects: BoundedVec<Option<Select>, N>,\n) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (Note, Field)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note = unsafe { get_note_internal(storage_slot) };\n\n    // Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do is check that\n    // the metadata is correct, and that the note exists.\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::array::collapse(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> =\n        BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> Note\nwhere\n    Note: NoteInterface<N>,\n{\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length,\n    )[0]\n        .expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteInterface<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteInterface<N>,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "74": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "83": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "85": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use dep::protocol_types::debug_log::debug_log_format;\n\nuse crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    hash::{ArgsHasher, hash_args_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        arguments,\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n        key_validation_request::get_key_validation_request,\n        returns::pack_returns,\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\n        debug_log_format(\n            \"Context.note_hashes, after pushing new note hash: {0}\",\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\n        );\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: self.next_counter(),\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert(request.pk_m.hash() == pk_m_hash);\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index],\n                },\n            );\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // The oracle simulates the private call and returns the value of the side effects counter after execution of\n        // the call (which means that end_side_effect_counter - start_side_effect_counter is the number of side effects\n        // that took place), along with the hash of the return values. We validate these by requesting a private kernel\n        // iteration in which the return values are constrained to hash to `returns_hash` and the side effects counter\n        // to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "89": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    point::Point,\n    public_keys::{IvpkM, ToPoint},\n    scalar::Scalar,\n};\n\nuse crate::keys::secret_derivation::derive_aes_secret;\n\nuse std::aes128::aes128_encrypt;\n\npub struct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    pub fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    pub fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48]\n    where\n        T: ToPoint,\n    {\n        let full_key = derive_aes_secret(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nunconstrained fn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false,\n        },\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131,\n        160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171,\n        176, 218, 48, 209, 73, 89, 200, 209,\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n"
    },
    "90": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    encrypted_logs::payload::compute_private_log_payload,\n    note::{note_emission::NoteEmission, note_interface::NoteInterface},\n};\nuse dep::protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n};\n\n/// Computes private note log payload\nfn compute_payload<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> ([Field; PRIVATE_LOG_SIZE_IN_FIELDS], u32)\nwhere\n    Note: NoteInterface<N>,\n{\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n\n    let plaintext = note.to_be_bytes(storage_slot);\n\n    let payload = compute_private_log_payload(contract_address, recipient, sender, plaintext);\n\n    (payload, note_hash_counter)\n}\n\nunconstrained fn compute_payload_unconstrained<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> ([Field; PRIVATE_LOG_SIZE_IN_FIELDS], u32)\nwhere\n    Note: NoteInterface<N>,\n{\n    compute_payload(context, note, recipient, sender)\n}\n\n// This function seems to be affected by the following Noir bug:\n// https://github.com/noir-lang/noir/issues/5771\n// If you get weird behavior it might be because of it.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        let (encrypted_log, note_hash_counter) =\n            compute_payload(*context, e.note, recipient, sender);\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        //   Unconstrained logs have both their content and encryption unconstrained - it could occur that the\n        // recipient is unable to decrypt the payload.\n        //   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can have\n        // more than one log and removes all of the matching ones, so all a malicious sender could do is either: cause\n        // for the log to be deleted when it shouldn't have (which is fine - they can already make the content be\n        // whatever), or cause for the log to not be deleted when it should have (which is also fine - it'll be a log\n        // for a note that doesn't exist).\n        //   It's important here that we do not\n        // return the log from this function to the app, otherwise it could try to do stuff with it and then that might\n        // be wrong.\n        let (encrypted_log, note_hash_counter) =\n            unsafe { compute_payload_unconstrained(*context, e.note, recipient, sender) };\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n"
    },
    "92": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, PRIVATE_LOG_SIZE_IN_FIELDS},\n    hash::poseidon2_hash,\n    point::Point,\n    public_keys::AddressPoint,\n    scalar::Scalar,\n    utils::arrays::array_concat,\n};\nuse std::{\n    aes128::aes128_encrypt, embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    field::bn254::decompose, hash::from_field_unsafe as fr_to_fq_unsafe,\n};\n\nuse crate::{\n    encrypted_logs::header::EncryptedLogHeader,\n    keys::secret_derivation::derive_aes_secret,\n    oracle::{\n        notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n        random::random,\n    },\n    utils::{bytes::bytes_to_fields, point::point_to_bytes},\n};\n\n// 1 field is reserved for tag.\nglobal ENCRYPTED_PAYLOAD_SIZE_IN_BYTES: u32 = (PRIVATE_LOG_SIZE_IN_FIELDS - 1) * 31;\n\ncomptime global HEADER_SIZE: u32 = 48;\n\n// Bytes padded to the overhead, so that the size of the incoming body ciphertext will be a multiple of 16.\ncomptime global OVERHEAD_PADDING: u32 = 15;\n\npub comptime global OVERHEAD_SIZE: u32 = 32 /* eph_pk */\n    + HEADER_SIZE /* incoming_header */\n    + OVERHEAD_PADDING /* padding */;\n\nglobal PLAINTEXT_LENGTH_SIZE: u32 = 2;\n\n// This is enough for 8 fields of data.\n// 1 field for storage slot, 1 field for note/event type id, allowing 6 fields for custom values.\nglobal MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES: u32 =\n    ENCRYPTED_PAYLOAD_SIZE_IN_BYTES - OVERHEAD_SIZE - PLAINTEXT_LENGTH_SIZE - 1 /* aes padding */;\n\n// Note: Might have to update PRIVATE_LOG_SIZE_IN_FIELDS in `constants.nr` if the above changes.\n// This value ideally should be set by the protocol, allowing users (or `aztec-nr`) to fit data within the defined size limits.\n// Currently, we adjust this value as the structure changes, then update `constants.nr` to match.\n// Once the structure is finalized with defined overhead and max note field sizes, this value will be fixed and should remain unaffected by further payload composition changes.\n\npub fn compute_private_log_payload<let P: u32>(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    plaintext: [u8; P],\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n    assert(\n        P < MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES,\n        f\"plaintext for log must not exceed {MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES}\",\n    );\n\n    let extended_plaintext: [u8; MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES + PLAINTEXT_LENGTH_SIZE] =\n        extend_private_log_plaintext(plaintext);\n    let encrypted: [u8; ENCRYPTED_PAYLOAD_SIZE_IN_BYTES] =\n        compute_encrypted_log(contract_address, recipient, extended_plaintext);\n\n    // We assume that the sender wants for the recipient to find the tagged note, and therefore that they will cooperate\n    // and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the note\n    // automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    array_concat([tag], bytes_to_fields(encrypted))\n}\n\npub fn compute_partial_public_log_payload<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    plaintext: [u8; P],\n) -> [u8; M] {\n    let extended_plaintext: [u8; P + PLAINTEXT_LENGTH_SIZE] =\n        extend_private_log_plaintext(plaintext);\n    let encrypted: [u8; M - 32] =\n        compute_encrypted_log(contract_address, recipient, extended_plaintext);\n\n    // We assume that the sender wants for the recipient to find the tagged note, and therefore that they will cooperate\n    // and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the note\n    // automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n    // Silo the tag with contract address.\n    // This is done by the kernel circuit to the private logs, but since the partial log will be finalized and emitted\n    // in public as unencrypted log, its tag is not siloed at the moment.\n    // To avoid querying logs using two types of tags, we silo the tag manually here.\n    // TODO(#10273) This should be done by the AVM when it's processing the raw logs instead of their hashes.\n    let siloed_tag_bytes: [u8; 32] =\n        poseidon2_hash([contract_address.to_field(), tag]).to_be_bytes();\n\n    // Temporary hack so that the partial public log remains the same format.\n    // It should return field array and make the tag the first field as compute_private_log_payload does.\n    let mut log_bytes = [0; M];\n    for i in 0..32 {\n        log_bytes[i] = siloed_tag_bytes[i];\n    }\n    for i in 0..encrypted.len() {\n        log_bytes[i + 32] = encrypted[i];\n    }\n\n    log_bytes\n}\n\nfn compute_encrypted_log<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    plaintext: [u8; P],\n) -> [u8; M] {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] =\n        header.compute_ciphertext(eph_sk, recipient.to_address_point());\n    let incoming_body_ciphertext =\n        compute_incoming_body_ciphertext(plaintext, eph_sk, recipient.to_address_point());\n\n    let mut encrypted_bytes = [0; M];\n    let mut offset = 0;\n\n    // eph_pk\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[offset + i] = eph_pk_bytes[i];\n    }\n    offset += 32;\n\n    // incoming_header\n    for i in 0..HEADER_SIZE {\n        encrypted_bytes[offset + i] = incoming_header_ciphertext[i];\n    }\n    offset += HEADER_SIZE;\n\n    // Padding.\n    offset += OVERHEAD_PADDING;\n\n    // incoming_body\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - offset;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[offset + i] = incoming_body_ciphertext[i];\n    }\n\n    encrypted_bytes\n}\n\n// Prepend the plaintext length as the first byte, then copy the plaintext itself starting from the second byte.\n// Fill the remaining bytes with random values to reach a fixed length of N.\nfn extend_private_log_plaintext<let P: u32, let N: u32>(plaintext: [u8; P]) -> [u8; N] {\n    let mut padded = unsafe { get_random_bytes() };\n    padded[0] = (P >> 8) as u8;\n    padded[1] = P as u8;\n    for i in 0..P {\n        padded[i + PLAINTEXT_LENGTH_SIZE] = plaintext[i];\n    }\n    padded\n}\n\nunconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    // We use the randomness to preserve the privacy of both the sender and recipient via encryption, so a malicious\n    // sender could use non-random values to reveal the plaintext. But they already know it themselves anyway, and so\n    // the recipient already trusts them to not disclose this information. We can therefore assume that the sender will\n    // cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(randomness);\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\npub fn compute_incoming_body_ciphertext<let P: u32>(\n    plaintext: [u8; P],\n    eph_sk: Scalar,\n    address_point: AddressPoint,\n) -> [u8] {\n    let full_key = derive_aes_secret(eph_sk, address_point.to_point());\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(plaintext, iv, sym_key)\n}\n\nmod test {\n    use crate::encrypted_logs::payload::{\n        compute_incoming_body_ciphertext, compute_private_log_payload,\n        MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES,\n    };\n    use dep::protocol_types::{address::AztecAddress, point::Point, scalar::Scalar};\n    use protocol_types::public_keys::AddressPoint;\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn test_encrypted_log_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_log_payload.test.ts`\n        let contract_address = AztecAddress::from_field(\n            0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04,\n        );\n\n        let plaintext = [\n            0, 0, 0, 1, 48, 22, 64, 206, 234, 117, 131, 145, 178, 225, 97, 201, 44, 5, 19, 241, 41,\n            2, 15, 65, 37, 37, 106, 253, 174, 38, 70, 206, 49, 9, 159, 92, 16, 244, 140, 217, 239,\n            247, 174, 91, 32, 156, 85, 124, 112, 222, 46, 101, 126, 231, 145, 102, 134, 134, 118,\n            183, 135, 233, 65, 126, 25, 38, 14, 4, 15, 228, 107, 229, 131, 183, 31, 74, 181, 183,\n            12, 38, 87, 255, 29, 5, 204, 207, 29, 41, 42, 147, 105, 98, 141, 26, 25, 79, 148, 78,\n            101, 153, 0, 0, 16, 39,\n        ];\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(\n            (MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES as u64 + 1 + 30) / 31,\n        );\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        let sender = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        let _ = OracleMock::mock(\"getAppTaggingSecretAsSender\").returns([69420, 1337]);\n\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let payload = compute_private_log_payload(contract_address, recipient, sender, plaintext);\n\n        // The following value was generated by `encrypted_log_payload.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let private_log_payload_from_typescript = [\n            0x0e9cffc3ddd746affb02410d8f0a823e89939785bcc8e88ee4f3cae05e737c36,\n            0x008d460c0e434d846ec1ea286e4090eb56376ff27bddc1aacae1d856549f701f,\n            0x00a70577790aeabcc2d81ec8d0c99e7f5d2bf2f1452025dc777a178404f851d9,\n            0x003de818923f85187871d99bdf95d695eff0a900000000000000000000000000,\n            0x000000a600a61f7d59eeaf52eb51bc0592ff981d9ba3ea8e6ea8ba9dc0cec8c7,\n            0x000b81e84556a77ce6c3ca47a527f99ffe7b2524bb885a23020b7295748ad19c,\n            0x001083618ad96298b76ee07eb1a56d19cc798710e9f5de96501bd59b3781c9c0,\n            0x002a6c95c5912f8936b1500d362afbf0922c85b1ada18db8b95162a6e9d06765,\n            0x005cdf669eb387f8e0492a95fdcdb39429d5340b4bebc250ba9bf62c2f49f549,\n            0x00f37beed75a668aa51967e0e57547e5a655157bcf381e22f30e25881548ec96,\n            0x0006a151b5fbfb2d14ee4b34bf4c1dbd71c7be15ad4c63474bb6f89970aeb3d9,\n            0x00489c8edbdff80a1a3a5c28370e534abc870a85ea4318326ea19222fb10df35,\n            0x008c765edada497db4284ae30507a2e03e983d23cfa0bd831577e857bbef9cf7,\n            0x0090c97cb5699cc8783a1b4276d929be2882e5b9b72829a4f8404f7e3c853d11,\n            0x00d6d5a000b80134891e95f81007ad35d3945eaeecbe137fff85d01d7eaf8f19,\n            0x00a15eb965c6a4bc97aa87fd3463c31c9d4e0d722a8ba870bcc50c9c7a8b48ad,\n            0x0063c861bdbe490d44c57382decbae663927909652f87ac18dcfd5b30649cce5,\n            0x00820f14caa725efe1fa3485ceac88499eadf0565c5b20998c05931bbf478e68,\n        ];\n\n        assert_eq(payload, private_log_payload_from_typescript);\n    }\n\n    #[test]\n    fn test_incoming_body_ciphertext_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n        };\n        let address_point = AddressPoint {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false,\n            },\n        };\n        let plaintext = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3,\n        ];\n\n        // `compute_incoming_body_ciphertext(...)` function then derives symmetric key from `eph_sk` and `address_point` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, address_point);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160,\n            190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157,\n            131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93,\n            46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130,\n            37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95,\n            115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234,\n            245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162,\n            25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185,\n            212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236,\n            23, 206, 229, 108,\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n}\n"
    }
  }
}
